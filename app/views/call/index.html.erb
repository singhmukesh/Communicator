<p id="notice"><%= notice %></p>

<div class="container well">

  <div id="video-container" class="rtccWebRTCControls" style="width:322px; height:182px; background:#ffffff; border: 1px solid black; display:none">
    <%= image_tag("Girl_with_a_Pearl_Earring.jpg", size: "320x180", style: "position:absolute") %>
    <%#= image_tag("SightCall_Logo.png", size: "320x180", style: "position:absolute") %>
  </div>

  <div class="col-sm-2 pull-right">
    <button disabled class="rtccCallActive btn btn-large btn-primary btn-block" onclick="hangup()">Hangup</button>
  </div>

</div>

<div class="container well">

  <div role="tabpanel">

    <!-- Nav tabs -->
    <ul class="nav nav-tabs" role="tablist">
      <li role="presentation" class="active"><a href="#call" aria-controls="call" role="tab" data-toggle="tab">Call</a></li>
      <li role="presentation"><a href="#conference" aria-controls="conference" role="tab" data-toggle="tab">Conference</a></li>
      <li role="presentation"><a href="#chat" aria-controls="chat" role="tab" data-toggle="tab">Chat</a></li>
    </ul>

    <!-- Tab panes -->
    <div class="tab-content">

      <!-- TAB CALL -->
      <div role="tabpanel" class="tab-pane active" id="call">
        <br>
        <div class="form-horizontal">
          <div class="form-group">
            <label for="call_friend" class="col-sm-1 control-label">Friend:</label>
            <div class="col-sm-3">
              <%= select_tag("call_friend", options_from_collection_for_select(@friends, 'rtcc_uid', 'name'), {id: "call_friend_select", class: "form-control"}) %>
            </div>
            <div class="col-sm-2">
              <button id="call_button" disabled class="rtccConnectionActive btn btn-large btn-primary btn-block" onclick="call()">Call</button>
            </div>
          </div>
        </div>
      </div>

      <!-- TAB CONFERENCE -->
      <div role="tabpanel" class="tab-pane" id="conference">
        <br>
        <div class="form-horizontal">
          <div class="form-group">
            <div class="col-sm-3">
              <button id="host_button" disabled class="rtccConnectionActive btn btn-large btn-primary btn-block" disabled onclick="createMeetingPoint()">Begin Hosting</button>
            </div>

            <div class="col-sm-2">
              <button id="recording_start_button" disabled class="rtccCallActive btn btn-large" onclick="newRecording()" >Record Start</button>
            </div>
            <div class="col-sm-2">
              <button id="recording_stop_button" disabled class="rtccCallActive btn btn-large" onclick="stopRecording()" >Record Stop</button>
            </div>
            <div class="col-sm-2">
              <span id="recording_counter" style="color:red"></span>
            </div>
            <div class="col-sm-3">
              <span id="recording_results"></span>
            </div>
          </div>

          <div class="form-group">

            <label for="conf_friend" class="col-sm-1 control-label">Friend:</label>
            <div class="col-sm-3">
              <%= select_tag("conf_friend", options_from_collection_for_select(@friends, 'rtcc_uid', 'name'), {id: "conf_friend_select", class: "form-control"}) %>
            </div>
            <div class="col-sm-2">
              <button id="invite_button" disabled class="rtccCallActive btn btn-large btn-primary btn-block" onclick="invite()">Invite</button>
            </div>
          </div>
        </div>
      </div>

      <!-- TAB CHAT -->
      <div role="tabpanel" class="tab-pane" id="chat">
        <br>
        <div class="form-horizontal">
          <div class="form-group">
            <label for="chat_friend" class="col-sm-1 control-label">Friend:</label>
            <div class="col-sm-3">
              <%= select_tag("chat_friend", options_from_collection_for_select(@friends, 'rtcc_uid', 'name'), {id: "chat_friend_select", class: "form-control"}) %>
            </div>
            <div class="col-sm-2">
              <button id="chat_button" disabled class="rtccConnectionActive btn btn-large btn-primary btn-block" onclick="chat()">Chat</button>
            </div>
          </div>
        </div>
      </div>
    </div>

  </div>



</div>

<script>

 ////////////////////////////////////////////////////////////////
 //
 // PAGE-GLOBAL Variables
 //

 var rtccAppId = "<%= RTCC_APP_ID %>";
 var rtcc = null;
 var rtccCall = null;
 var rtccChatWindows = { };
 var rtccChatManagers = { };

 var rtccCloudrecorderManager = null;
 var rtccRecording = null;
 var rtccRecordingCounter = null;

 var MPI = null;

 ////////////////////////////////////////////////////////////////
 //
 // get an RTCC token for the current user
 //

 function getToken(url, success, failure) {
   $.ajax({
     type: "POST",
     url: url,
     cache: false,
     dataType: "JSON"
   }).success(function(data) {
     console.log(["RtccToken Success", data]);
     success(data);
   }).error(function(e) {
     console.log(["RtccToken error", e]);
     failure(e);
   });
 }

 //
 // getToken, set it and authenticate (again)
 //

 function setTokenAndAuthenticate(url) {
   getToken(
     url,
     function(data) {
       var token = data.token;
       rtcc.setToken(token);
       rtcc.authenticate(1);
     }, function(e) {
       // the default prints it already
     });
 }

 //
 // Initialize Real-Time Communication
 //

 function initializeRtcc(rtccAppId, token, displayName) {
   var options = {
     debugLevel: 3,
     displayName: displayName,
     container: 'video-container'
     
   };
   rtcc = new Rtcc(rtccAppId, token, 'internal', options);

   // Get the Connection Handler callback when the JavaScript is connected to WeempoDriver
   rtcc.onConnectionHandler = function(message, code) {
     console.log(['onConnectionHandler', message, code]);
     switch(message) {

       case 'connectedRtccDriver':
         $(".rtccConnectionStatus").addClass("connected")
         break; 

       case 'connectedWebRTC':
         $(".rtccConnectionStatus").addClass("connected")
         $(".rtccWebRTCControls").show();
         break;

       case 'disconnectedRtccDriver':
         $(".rtccConnectionStatus").removeClass("connected")
         $(".rtccConnectionActive").attr("disabled", "disabled");
         setTokenAndAuthenticate("/rtcc/callback");
         break;

       case 'disconnectedWebRTC':
         $(".rtccConnectionStatus").removeClass("connected")
         $(".rtccConnectionActive").attr("disabled", "disabled");
         setTokenAndAuthenticate("/rtcc/callback");
         break;

       case 'sipOk':
         // look for class rtccConnectionActive and mark enabled
         $(".rtccConnectionActive").removeAttr("disabled");
         break;

       case 'sipNok':
         // look for class rtccConnectionActive and mark disabled
         $(".rtccConnectionActive").attr("disabled", "disabled");
         break;

       case 'loggedasotheruser':
         setTokenAndAuthenticate("/rtcc/callback");
         break;
     }
   }
     
   rtcc.onCallHandler = function(call, args) {
     console.log(['onCallHandler', call, args]);
     rtccCall = call;

     // Handle incoming call
     if (args.type == 'webRTCcall' && args.status == 'incoming') {
       var ans = confirm("Accept call from '" + call.dn + "'?");
       if (ans == true) {
         rtccCall.accept();
       }
       else {
         rtccCall.hangup();
       }
     }

     // Handle refused call
     if (args.status == 'terminated' && args.reason == 'rejected') {
       alert("Call rejected");
     }

     // Handle call to UID not logged-in
     if (args.status == 'terminated' && args.reason == 'not found') {
       alert("User not logged in");
     }

     // Handle call to BUSY call
     if (args.status == 'terminated' && args.reason == 'busy') {
       alert("User is busy");
     }

     // Manage button highlighting
     if (args.status == "active") {
       // look for class rtccCallActive and mark enabled
       $(".rtccCallActive").removeAttr("disabled");
     }

     if (args.status == "terminated") {
       // look for class rtccCallActive and mark disabled
       $(".rtccCallActive").attr("disabled", "disabled");
     }

   }

   rtcc.onConfCallHandler = function(action, obj) {
     console.log(["rtccOnConfCallHandler", action, obj]);

     if (action == 'meetingPointCreated') {
       MPI = obj;       // the object is the meeting point
       MPI.autoaccept_mode(); // allow attendees to join with no confirmation
       MPI.host(); // start hosting the conference
     }

     if (action == 'attendeeInvited') {
       MPI = obj;       // the object is the meeting point       
       var ans = confirm("Accept conference invitation from '" + MPI.hostDisplayName + "'?");
       if (ans == true) {
         MPI.accept();
       }
       else {
         MPI.deny();
       }
     }

   }

   rtcc.onGetHandler = function(name, value) {
     console.log(['onGetHandler', name, value]);
   }

   rtcc.onDataChannelMessageReceived = function(oid, dispname, msg) {

     console.log(["onDataChannelMessageReceived", oid, dispname, msg]);

     // HACK - until 5.4 provides sendMessage
     var jdata = JSON.parse(msg);
     var uid = jdata[0];
     var msg = jdata[1];

     var chatManager = findChatManager(uid);
     console.log(["onDataChannelMessageReceived", chatManager]);

     chatManager.appendReceived(msg);
     console.log(["onDataChannelMessageReceived", "appendReceived", msg]);

     var win = findChatWindow(uid);
     console.log(["onDataChannelMessageReceived", "foundWindow", uid]);
     // win.chatManager.appendReceived(msg);
   }

   rtcc.onRtccDriverNotStarted = function(downloadUrl) {
     var answer = confirm('Click OK to download and install the RTCC Client.');
     if (answer == true) {
       window.location = downloadUrl;
     }
   };

   rtcc.initialize();
 }

 //
 // Create a one-to-one call
 //

 function call() {
   var friendUid = $("#call_friend_select").val()
   console.log(["call", friendUid]);
   rtcc.createCall(friendUid, 'internal', "<%= current_user.name %>");
 }

 //
 // Create a new meeting point.  Upon success, begin hosting the multiparty call of the meeting point.
 // (See 'meetingPointCreated' above.)
 //

 function createMeetingPoint() {
   var options = new Object();
   options.startDate = new Date();
   options.stopDate = new Date();
   options.location = "San Francisco";
   options.title = "teleportation";
   MPI = rtcc.createMeetingPoint('scheduled', options);
 }

 //
 // Invite a friend to join our multiparty call.
 //

 function invite() {
   var friendUid = $("#conf_friend_select").val();
   console.log(["invite", friendUid]);   
   MPI.invite(friendUid)
 }

 //
 // Send a chat message to a friend
 //

 function chat() {
   var friendUid = $("#chat_friend_select").val();
   console.log(["chat", friendUid]);
   var win = findChatWindow(friendUid);
 }

 //
 // Hang-up the current call
 //

 function hangup() {
   rtccCall.hangup();
 }

 ////////////////////////////////////////////////////////////////
 //
 // Find or allocate a ChatManager by UID
 //

 function findChatManager(uid) {

   if (uid in rtccChatManagers) {
     var chatManager = rtccChatManagers[uid];
     return chatManager;
   }
   else {
     var chatManager = new ChatManager(rtcc, "<%= @me.rtcc_uid %>", uid)
     rtccChatManagers[uid] = chatManager;
     return chatManager;
   }

 }

 //
 // Find or allocate a chat window by UID
 //

 function findChatWindow(uid) {

   function openChatWindow(uid) {

     // Each UID has its own chat window
     var euid = encodeURIComponent(uid);
     var win = window.open("/chat?uid=" + euid, "chat window" + euid, "width=400,height=300,status=no,toolbar=no,menubar=no,location=0");

     if (win == null || typeof(win) == 'undefined') {
       alert("Please disable your pop-up blocker on this site and re-load the page.  Chat windows use pop-ups.");
     }

     return win;
   }

   if (uid in rtccChatWindows) {
     var win = rtccChatWindows[uid];
     if (win.closed == true) {
       win = openChatWindow(uid);
       rtccChatWindows[uid] = win;
       return win;
     }
     else {
       win.focus();
       return win;
     }
   }
   else {
     win = openChatWindow(uid);
     rtccChatWindows[uid] = win;
     return win;
   }
 }

 ////////////////////////////////////////////////////////////////
 //
 // Recording: Allocate a recording on the cloud recorder.  Upon creation, of an
 // start recording to the upload_url and begin an onscreen counter.
 //

 function newRecording() {

   // Allocate a new recording on the cloud recorder
   rtccCloudrecorderManager.create(
     // success
     function(recording) {
       rtccRecording = recording;
       rtccCall.recordStart(recording.upload_url, 7);
       rtccRecordingCounter = new CounterManager("#recording_counter", "");
     },
     // failure
     function(e) {
       console.log(["newRecording: error", e]);
     }
   );
 }


 //
 // Recording: Stop the current recording, stop the counter.
 // Begin polling for movie files on the cloud-recorder
 //

 function stopRecording() {
   if (rtccCall != null) {
     rtccCall.recordStop();
     rtccRecordingCounter.stop();
     $("#recording_counter").html("recording stopped");
     pollForRecordingDetail(0);
   }
 }

 // Recording: format the URLs of the movie types the cloud-recorder
 // might return.
 
 function createWebmAndMp4Urls(recording) {
   var webm_s3url = recording.webm_s3url
   var mp4_s3url = recording.mp4_s3url;
   var vb_fileurl = recording.vb_fileurl;

   var result = "Movies: ";
   if (webm_s3url != null) {
     result = result + "<a href=\"" + webm_s3url + "\" target=_new> webm </a> ";
   }
   if (mp4_s3url != null) {
     result = result + "<a href=\"" + mp4_s3url + "\" target=_new> mp4 </a> ";
   }
   if (vb_fileurl != null) {
     result = result + "<a href=\"" + vb_fileurl + "\" target=_new> vb </a> ";
   }
     
   return result;
 }

 // Recording: Poll the cloud-recorder for status changes on the current recording.
 // Format a helpful message in the progress area.

 function pollForRecordingDetail(cnt) {
   if (cnt > 200) {
     // do not poll forever
     return;
   }

   rtccCloudrecorderManager.detail(
     rtccRecording,
     // success
     function(recording) {
       console.log(["poll recording", recording]);

       if (recording.status != "done") {
         setTimeout(function() { pollForRecordingDetail(cnt+1) }, 1000);
         $("#recording_results").html("Movies: <progress max=\"100\"></progress>");         
       }
       else {
         $("#recording_results").html(createWebmAndMp4Urls(recording));
       }
     },
     // failure
     function(e) {
       console.log(["RtccRecording Error", e]);
     }
   );
 }


 ////////////////////////////////////////////////////////////////
 //
 // Kick-off this application on page load
 //

 function documentReady() {

   // Initialize the cloudrecorder manager with the URLs of our proxy
   rtccCloudrecorderManager = new CloudrecorderManager(
     "<%= url_for :controller => :cloudrecorder, :action => :recording %>",
     "<%= url_for :controller => :cloudrecorder, :action => :detail %>"
   );

   getToken(
     "/rtcc/callback",
     function(data) {
        var token = data.token;
       initializeRtcc(rtccAppId, token, "<%= current_user.name %>");
     }, function(e) {
       // the default prints it already
     });
 }

 $(document).ready(documentReady);

</script>


