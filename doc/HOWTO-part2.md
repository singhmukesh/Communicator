Part 2: Integrating the Weemo Auth Client into a Rails app
================================================================

In Part 1 of this series, we built a little web site in Rails that had
a login page and a single index page.  To view the index page, a user
needs to be logged in.

In Part 2 of this series, we will add the Weemo security credentials
into the web site.  We will link the Weemo Javascript into the page,
and we will use Javascript to create video calls between different
users logged into the web site.

This tutorial is broadly applicable to the development of any Rails
application using Weemo.  The information in here applies whether you
are coming from Part 1 of our Tutorial Series, or are developing your
own Rails site.


Get your Credentials
----------------

If you have not already, you must request an API KEY from Weemo.  In
response to this request, Weemo will provide you access to a portal
from which to access the certificates and keys your web site will use
to enable video chat.


Include the Ruby Authentication Client, Prepare the Certificates
----------------

Our Rails server will incorporate the Ruby authentication client from
https://github.com/weemo/Server-SDKs/tree/master/Ruby.  Copy the file
```lib/weemo_auth.rb``` into the ```lib/``` directory of the Rails
project.  Rails automatically loads everything in the lib directory
when it starts.

You will need to put the certificate files you retrieve from the
provider portal on your Rails server.  It is good practice to not
check certificates into a repository, so you may want to put them
somewhere outside of the Rails project.

Following the instructions in
[Ruby](https://github.com/weemo/Server-SDKs/tree/master/Ruby)
collection, we see that we need to unpack the ```client.p12``` file
into its two components.

- ```privateKey.pem```
- ```publicCert.pem```


Follow the instructions in the Server-SDKs Ruby README file and unpack
the certificates.



Add the Keys and Certs to the Rails Environment
----------------

Open up the file config/environment.rb and add the global variables
describing your configuration.  These lines should go right before the
```Application.initialize!``` call.

```ruby
# config/environment.rb

# Path to the Weemo CA Cert
WEEMO_CACERT = "/Path/To/Your/Cert/weemo-ca.pem"

# Paths to the extracted key and cert from the client.p12 file
WEEMO_CLIENTCERT = "/Path/To/Your/Cert/publicCert.pem"
WEEMO_CLIENTCERT_KEY = "/Path/To/Your/Cert/privateKey.pem"

# Password
WEEMO_CERTPASSWORD = "abcdefgh"

# Weemo Auth endpoint, Client ID and Secret
WEEMO_AUTH_URL = "https://oauths.weemo.com/auth/"
WEEMO_CLIENT_ID = "7a7a7a7a7a8b8b8b8b8b9c9c9c9c9c"
WEEMO_CLIENT_SECRET = "19ab19ab19ab19ab28cd28cd28cd28"

# Weemo App ID
WEEMO_APP_ID = "ab01cd34ef56"
```


Extend the User Model
----------------

Our User model defines the type of information associated with each
user in the system.  We will now extend the User model to provide
information that will be used to authenticate a user to Weemo.  Add
the following three methods to User class by editing
app/models/user.rb.



```ruby
# app/models/user.rb

  def weemo_uid
    "#{name}-uid"
  end

  def weemo_profile
    "premium"
  end

  def weemo_domain
    "yourdomain.com"
  end
```

The purpose of each of these fields is explained in a little more
detail on https://github.com/weemo/Server-SDKs, if you would like to
know more.  The weemo_uid method returns the User Identifier that we
will send to Weemo.  In our example system here, that will be the
user's name followed by "-uid".  The UID should be unique in the
system because it is the way that Weemo will provide accounting
information about each user and their calls.  The UID can be something
else, if that's more appropriate, like a user's email, or an opaque
UDID generated by your system.  In this tutorial, we are appending the
"-uid" suffix so that the roles of names and UIDs is clear.  Whatever
mapping you choose, you can define it in this method.

The weemo_profile maps a user to their capabilities on Weemo.  In our
example here, every user will have "premium" access.  Your Weemo
account may have different profile levels.  If it does, this method is
where you can encapsulate the logic that maps your users to Weemo
profiles.

Lastly, the weemo_domain is an identifier you were provided when you
received your Weemo credentials.  (If you are a multi-tenant provider,
contact your Weemo support representative for more information on how
to use this field.)




Create a Weemo Controller
----------------

Next, we will create a controller whose job it will be to use the
Weemo Auth client to request a token on behalf of an authenticated
user.  This controller will implement a single method called
'callback' that returns an access token.  It will be called using Ajax
from a web page using Weemo for WebRTC.

Instead of using a Rails generator, we will contruct this simple
controller by hand.  First, add the following route to the routes
file.

```ruby
# config/routes.rb
post "weemo/callback"
```

The reason we chose to map this method with a POST is that Rails
includes CSRF protection for POST methods, but not GET methods.  The
test for a signed-in user should be enough to prevent handing out
tokens to the wrong place, but requiring the request to come from a
page that we rendered adds an extra layer of security.

Now implement the controller and method.  Upon initialization (when
the server starts), the controller will instantiate a Weemo
authentication client with the certificates and API KEY we installed
earlier.  Remember that all of these values were set globally in the
config/environment.rb file.

The callback method becomes very simple, indeed.  It checks if there
is a signed-in user.  If there is, it uses the client to request a
token using the uid, domain and profile of the current user.  Voila!
A token is granted.


```ruby
# app/controllers/weemo_controller.rb
require 'weemo_auth'

class WeemoController < ApplicationController

  def initialize
    @client = WeemoAuth.new(WEEMO_AUTH_URL, WEEMO_CACERT, WEEMO_CLIENTCERT,
                            WEEMO_CLIENTCERT_KEY, WEEMO_CERTPASSWORD, WEEMO_CLIENT_ID, WEEMO_CLIENT_SECRET)
    super
  end

  def callback
    if user_signed_in?
      obj = @client.auth(current_user.weemo_uid,
                         current_user.weemo_domain,
                         current_user.weemo_profile)
    else
      obj = { "error" => 500, "error_description" => "unauthenticated user" }
    end

    logger.debug "Weemo#callback #{obj}"

    render :json => obj
  end
end
```


## Test what we have done so far

At this point, our web site should be able to grant a Weemo token to a
logged-in user.  To test our progress at this point, we will take a
little detour and modify our index page to get a token for the current
user by using ajax.

Add a script section to the `index.html.erb` view.  When the page loads, this bit
of code will use Ajax to perform a POST request to the weemo/callback
method.  If all has gone well you will see a JSON object in the page
showing the token retrieved.

```html
# app/views/call/index.html
<script>
$.ajax({
    type: "POST",
    url: "/weemo/callback",
    cache: false,
    dataType: "JSON"
}).success(function(data) {
   $("body").append("<b>" + JSON.stringify(data) + "</b>");
}).error(function(e) {
   $("body").append("<b>Error:" + e.statusText + "</b>");
});
</script>

```

The JSON token result will look something like this.

```
{"token":"47d00e8bb977dbdea63003009ef2805a9d6eb03c"}
```

If you are happy that the Weemo authentication procedure is working
and that you received a token, you should remove the script code from the
index page.  We will not need it on our next steps.


<hr>

[ Back to [Part 1](HOWTO-part1.md) | Continue to [Part 3](HOWTO-part3.md) ]
